const BaseModel = require('./base')
const hashId = require('objection-hashid')
const httpError = require('http-errors')
const scrape = require('../lib/scrape')

const { URL } = require('url')
const normalizeURL = require('normalize-url')
const domain = new URL(process.env.BASE_URL).host

class Link extends hashId(BaseModel) {
  static get relationMappings() {
    return {
      creator: {
        type: BaseModel.BelongsToOneRelation,
        modelClass: 'user',
        join: {
          from: 'links.creatorId',
          to: 'users.id'
        }
      }
    }
  }

  // process JSON from user input synchronously
  $parseJson(json, opt) {
    json = super.$parseJson(json, opt)

    if (json.hash) {
      // Since custom and auto-generated hash are both mounted under /,
      // we need to check that custom hash CAN'T clash with autogenerated hash.
      const ids = this.constructor._hashIdInstance.decode(json.hash)
      if (ids.length) throw httpError(400, 'Cannot use hash ' + json.hash)
    }

    if (json.originalURL) {
      try {
        // Normalize URL so that we can search by URL.
        // The process of normalization also involves validating the (normalized) URL.
        // When an invalid link is passed, it will throw.
        // Note that we do not have to worry about catching a specific error type,
        // or enriching the error object with any status codes,
        // since we catch all errors in this block - which are all input checks -
        // and re-throw them as 400 errors.
        json.originalURL = normalizeURL(json.originalURL, { forceHttps: true })

        if (new URL(json.originalURL).host === domain)
          throw new Error(`Cannot shorten ${domain} URLs`)
      } catch (err) {
        throw httpError(400, err)
      }
    }

    return json
  }

  async $beforeInsert(queryContext) {
    await super.$beforeInsert(queryContext)

    // update metadata by visiting the URL
    this.meta = Object.assign(await scrape(this.originalURL), this.meta)
  }

  static get virtualAttributes() {
    return ['shortenedURL', 'brandedURL']
  }

  get shortenedURL() {
    return `${process.env.BASE_URL}/${this.hashId}`
  }

  get brandedURL() {
    return this.hash ? `${process.env.BASE_URL}/${this.hash}` : undefined
  }

  static get hashIdSalt() {
    return domain
  }

  static get hashIdMinLength() {
    return this.jsonSchema.properties.hash.minLength
  }

  static get QueryBuilder() {
    return class extends super.QueryBuilder {
      // if the hash is encoded, search for the id, else search hash directly
      findByHashId(hash) {
        const ids = this.modelClass()._hashIdInstance.decode(hash)

        return ids.length ? this.findById(ids[0]) : this.findOne({ hash })
      }
    }
  }
}

module.exports = Link
